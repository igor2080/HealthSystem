@page "/messages"
@using HealthSystem.Data
@using static Data.Utils
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider GetAuthenticationStateAsync
@inject IJSRuntime JSRuntime
@attribute [Authorize]
@rendermode InteractiveServer

<div class="container">
    <div class="messageList">
        <div class="messageListTitle">Messages</div>
        @foreach (var thread in _messageThreads)
        {
            <div class="messageThread @(thread[0].ReadDate.HasValue?"":"bold") @(thread[0].Id==_currentMessageId?"active":"")" @onclick="async ()=>{await SetActive(thread[0].Id);}">
                <div class="messageThreadDate">@thread.Last().Date</div>
                <div class="messageThreadTitle">
                    <div class="threadTitle">@thread[0].Title</div>
                    @if (string.IsNullOrEmpty(thread[0].Image))
                    {
                        <div class="threadMessageIcon"></div>
                    }
                    else
                    {
                        <div class="threadMessageIcon"><button @onclick="@(()=>{DownloadImage(thread[0].Image);})"></button></div>
                    }

                </div>
            </div>
        }
    </div>
    <div class="messageDetails">
        @if (_currentMessageId > 0)
        {
            <div class="messageContentTitle">
                Message
            </div>

            <div class="messageContent">
                @foreach (var threadMessage in _currentThread)
                {
                    <div class="@(threadMessage.SenderId == _user.Id ? "right" : "left")">
                        @threadMessage.Content
                    </div>
                }
            </div>
            <hr />

            <div class="reply">
                <span>Reply</span>
                <EditForm method="post" Model="Message" OnValidSubmit="SendResponse">
                    <DataAnnotationsValidator />
                    <ValidationSummary class="text-danger" role="alert" />
                    <div class="mb-3">
                        <label for="description" class="form-label">Message:</label>
                        <InputText id="description" @bind-Value="Message.Content" class="form-control" />
                        <ValidationMessage For="() => Message.Content" class="text-danger" />
                    </div>
                    <button type="submit" class="btn btn-primary">Reply</button>
                </EditForm>
            </div>
        }
    </div>
</div>


@code {
    Message Message { get; set; } = new();
    List<Message> _messages = new();
    List<List<Message>> _messageThreads = new();
    int _currentMessageId = 0;
    List<Message> _currentThread;
    ApplicationUser _admin;
    ApplicationUser _user;

    protected override async Task OnInitializedAsync()
    {
        _admin = await UserManager.FindByEmailAsync("admin@site.com");

        var authState = await GetAuthenticationStateAsync.GetAuthenticationStateAsync();
        _user = await UserManager.FindByEmailAsync(authState.User.Identity.Name);

        using var Context = DbFactory.CreateDbContext();
        //all sent and received messages, should include all of the "related" messages too as users cannot send to other users
        _messages = Context.Message.Include("Sender").Include("Receiver").Where(x => x.SenderId == _user.Id || x.ReceiverId == _user.Id).OrderByDescending(x => x.Date).ToList();
        //all of the messages that were conversation starters
        _messageThreads = GetMessagesByThread(_messages);
    }

    async Task SendResponse(EditContext editContext)
    {
        Message.SenderId = _user.Id;
        Message.ReceiverId = _admin.Id;
        Message.Date = DateTime.Now;
        Message.PreviousMessageId = _currentThread.Last().Id;
        Message.Title = _currentThread.First().Title;

        using var Context = DbFactory.CreateDbContext();
        Context.Message.Add(Message);
        await Context.SaveChangesAsync();
        //add the message to the current thread without re-fetching it from the database
        _currentThread.Add(Message);
        _messages = Context.Message.Include("Sender").Include("Receiver").Where(x => x.SenderId == _user.Id || x.ReceiverId == _user.Id).OrderByDescending(x => x.Date).ToList();
        _messageThreads = GetMessagesByThread(_messages);
        Message.Content = "";
        StateHasChanged();
    }

    async Task SetActive(int messageId)
    {
        _currentMessageId = messageId;
        _currentThread = _messageThreads.Single(x => x[0].Id == messageId);
        //make sure the messages are in the right chronological order(oldest first)
        _currentThread = _currentThread.OrderBy(x => x.Date).ToList();

        using var Context = DbFactory.CreateDbContext();
        Context.Message.Single(x => x.Id == messageId).ReadDate = DateTime.Now;
        await Context.SaveChangesAsync();
        StateHasChanged();
    }

    async Task DownloadImage(string image)
    {
        await JSRuntime.InvokeVoidAsync("downloadImage", image);
    }
}
